\chapter{Human Computable Passwords}
The previous chapter concludes that managing passwords for online accounts has become a major issue for the modern Internet user. It seems to be impossible to remember and maintain enough strong passwords to keep all accounts secured. The scheme presented in this chapter is designed to help the user maintain and remember multiple strong passwords, while also protecting these after multiple passwords breaches. Human computable passwords takes advantage of the human brain allowing users to calculate passwords from public challenges, using their own mind to do so. 

\par The Human Computable Password management scheme is proposed by Blocki et al. in the paper \cite{hcp-blocki}. In addition to the scheme itself, the proposal introduce security and usability notions used to analyze the proposed scheme. This chapter will describe the scheme as well as associated security and usability concerns. The first section consist of definitions and notations as used in \cite{hcp-blocki} to describe the scheme. Next, Human computable Functions are introduced as this the main component used in the password management scheme which will be described after that. Finally the usability and security of the scheme is discussed and requirements defined.

\section{Password Management Scheme}
The main idea of the Human Computable Password management scheme is to have a set of challenges stored in persistent memory, typically on a computer or even a piece of paper. The user then use a mapping and a function to calculate the responses to each challenge, which eventually gives the password.

\subsection{Definitions and Notation}
The password management scheme uses a random mapping between a set of objects to single digits which has to be memorized by the user. This mapping is denoted as $\sigma : [n] \rightarrow \mathbb{Z}_d$. Random challenges will be generated and stored publicly in persistent memory. Let $C \in X_k$ be a random challenge chosen from $X_k$, the space of $k$ possible variables. Now $\sigma (C) \in \mathbb{Z}_d^k$ is the mapped variables corresponding to challenge $C$. The set of challenges $C$ can be any type of object, such as pictures letters or digits, with the mapping $\sigma$ always being to digits. One of these challenges, $C$, will be referred to as a \emph{single digit challenge}. The function $f: \mathbb{Z}^k_d \rightarrow \mathbb{Z}_d$ is a human computable function as discussed in the next section. The user will now be able to calculate the response to a challenge $C$ by computing $f(\sigma(C))$. A complete password challenge, $\vec(C) = (C_1,\dots,C_t) \in (X_k)^t$ , will consist of $t$ separate, single digit challenges. The response to $\vec(C)$, namely $f(\sigma(\vec(C)))$, is the complete password. 
\par The password management scheme works by generating one challenge, $\vec(C)$, for each of a user's accounts $A_1,\dots,A_m$. The challenges $\vec(C_1),\dots,\vec(C_m) \in (X_k)^t$ are stored in persistent memory, available to "everybody". When a user wants to log in to a service he is shown the challenge corresponding to that account, the user then calculate the responses to all the single digit challenges, yielding the password.

\subsection{Human Computable Functions}
At the core of the scheme is a human computable function $f$ and the memorized mapping $\sigma$. The scheme require the composite function of these two $f \circ \sigma$ to be \emph{human computable}, which simply means that the function should be easily computable in the head of the user. To fulfill this requirement the function can't involve many operations, since the complexity and thus computation time would be too high. As shown by Miller \cite{magic-seven_miller}, a human can only store $7 \pm 2$ pieces of information at a given time, on the other hand humans are quite good at simple operations such as addition modulo 10. In example "1+6+5+3+8+9+3+1+4+6+7+7+6 mod 10" would be easy for most humans to compute by simply doing one operation at a time, updating the answer after each. With this approach only one piece of information would be stored in memory of the user at any time. The problem with such an expression is the amount of terms. 
\par The requirements needed for a function to be human computable can thus be summarized as the following, and formalized in Requirement \ref{human-function-req}:
\begin{itemize}
    \item Can only involve "simple" operations, mainly addition and recalling from long-term memory.
    \item Limited amount of terms.
    \item Limited amount of operations.
\end{itemize}
\begin{remark}
    All operations used in the human computable functions discussed in this project are modulo $10$, this is the most natural for most humans.
\end{remark}
\begin{requirement}
    \label{human-function-req}
    Function $f$ is said to be $\hat t$-human computable if a human can can compute it in his head in $\hat t$ seconds.
\end{requirement}

\par Blocki et al. \cite{hcp-blocki} believe that a function $f$ is human-computable if it can be computed using a fast streaming algorithm, meaning that the input is presented as a sequence of objects that only can be evaluated once. The algorithm would have to be simple since humans are not good at storing intermediate values \cite{magic-seven_miller}. Typical operations fast enough for the human to compute in his head is addition modulo 10 which is natural for most humans to do quickly, and recalling a mapped value $\sigma(i)$ from memory.

\begin{definition}
    \label{ptm-computable}
    A function $f$ is $(P, \tilde t, \hat m)$-computable if there is a space $\tilde m$ streaming algorithm computing $f$ using $\hat t$ operations from $P$.
\end{definition}
\begin{remark}
    Space $\tilde m$ means that the algorithm requires no more than $\tilde m$ memory slots during calculation. Slots are typically used for storing values and executing primitive operations such as addition~\cite{space-complexity}.
\end{remark}



\noindent As for the primitive operations in $P$, the following are considered:
\begin{itemize}
    \item{Add} takes two digits $x_1$ and $x_2$, and returns the sum $x_1 + x_2$ mod 10.
    \item{Recall} returns the secret value $\sigma(i)$ corresponding to a inputed index $i$. The mapping $\sigma$ is memorized by the user, allowing the recall operation to be done quickly in the users head.
    \item{TableLookup} involves looking up the x'th value from a table of 10 indices.
\end{itemize}

\begin{example}
    The function $f \circ \sigma(i_1,\dots,i_5) = \sigma(i_1) + \dots + \sigma(i_5)$ is $(P,9,3)$-computable, since it requires 9 operations from $P$, 5 recall operations and 4 add operations. $\tilde m=3$ since a sequence of additions $i_1 + \dots + i_n$, requires one slot for storing the sum, one slot for storing the next value in the sequence and one slot to execute the addition.
\end{example}


\subsection{Secure Human Computable Functions}
Blocki et al. \cite{hcp-blocki} suggest a family of human computable functions defined as follows.
\centerline{ $ f_{k_1,k_2}(x_0,\dots,x_{9+k_1+k_2})= x_j + \mathlarger{\sum}\limits^{9+k_1+k_2}_{i=10+k_1} x_i \quad mod\quad 10,$}\\
\centerline{with $j = \mathlarger{\sum}\limits^{9+k_1}_{i=10} x_i \quad mod \quad 10\quad$ and $\quad k_1>0$, $k_2>0$ }
\vspace{2mm}
\par This project will use one of these functions, with $k_1=k_2=2$. From now on this will be the function referred to as $f$. For an in depth analysis of this function see "Usable Human Authentication: A Quantitative Treatment"~\cite{Blocki2014}. Blocki argues that an adversary would have to see $\tilde \Omega(n^{1.5})$ challenge-response pairs to be able to start recovering the secret mapping $\sigma$. A realistic mapping $\sigma$ would probably consist of no more than 100 object to digit mappings. A secret mapping consisting of $n=100$ mappings would require an attacker to steal 1000 challenge-response pairs (100 accounts given password length of 10) to recover the secret mapping. In practice this might be the tricky part of the scheme, since memorizing a mapping of $100$ object-digit mappings might be possible, it might be more reasonable to use a smaller set of mappings which will lower the security of the scheme. An example mapping which could be feasible in practice is characters to single digits, with characters from the alphabet and digits between $1$ and $10$. This mapping would yield $n=26$ which would require an attacker to recover significantly less challenge-response pairs. With $n=26$ the amount is down to $133$ compared to the $1000$ with $n=100$. Still, this would require to fully compromise $13$ or more accounts with password lengths of $10$ characters.


\par There are some interesting trade-offs related to the parameters of the human computable passwords scheme. A bigger set of mappings makes it increasingly hard to recover the secret mapping, but it becomes equally hard to memorize and rehearse it. It is reasonable to say that complexity of a mapping grows linearly with the number of mappings $n$, and the resistance versus attackers grows polynomially, thus much quicker than the complexity, see \autoref{trade-off1}. In other words, for each mapping added to $\sigma$ $n$ is increased with one and the security multiplied $1.5$ times. The trade-off which would have to be evaluated for each user is then; how much effort is the user willing to put into memorizing the mappings versus how secure he wants it to be. This should be evaluated in regards to how "important" the passwords and the accompanying accounts are, and how many accounts the user plans on having. 
\par Another trade-off is acctually between password length and number of accounts which would have to be stolen. Assume that a set of mappings with $n=26$ is used


\begin{figure}
\begin{tikzpicture}
    \begin{axis}[axis lines = left, xlabel=$n$]
    \addplot[domain=0:10, samples=10, color=red]{x^1.5};
    \addlegendentry{$n^{1.5}$};
    \addplot[domain=0:10, samples=3, color=blue]{x};
    \addlegendentry{$n$};
\end{axis}
\end{tikzpicture}
\caption{Number of challenge-response pairs required to recover mapping $\sigma$ as a function of the size of the mapping $n$. }
\label{trade-off1}
\end{figure}


\begin{figure}
\begin{tikzpicture}
    \begin{axis}[axis lines = left, xlabel=$x$]
    \addplot[domain=5:30, samples=50, color=blue]{(26^1.5)/x};
    \addlegendentry{$\frac{26^{1.5}}{x}$};
\end{axis}
\end{tikzpicture}
\caption{Number of accounts needed to compromised to recover the mapping $\sigma$.}
\label{trade-off2}
\end{figure}

\begin{definition}
    $f(x_0,x_2,\dots,x_{13}) = x_{(x_{11} + x_{10}\quad mod \quad 10)} + x_{12} + x_{13}\quad mod \quad 10$ 
\end{definition}

\paragraph{}
\begin{algorithm}
    \caption{Create new challenge for account $A_j \in (A_1,\dots, A_m)$}\label{new-challenge}
    \begin{algorithmic}[1]
        \Require
            \Statex \begin{itemize}
                \item $t$ desired length of password.
                \item $\sigma$ secret mapping memorized by the user.
                \item $f$ a human computable function.
                \item $O_1,\dots,O_n$ objects, typically letters or pictures.
            \end{itemize}
            
        
        \For{$i=0 \rightarrow t$}
            \State $k \sim [0, n] $
            \State $C_i \leftarrow O_k $
        \EndFor
        \Statex
        \State $\vec C \leftarrow (C_1,\dots, C_t) $

        \State \textbf{(User)} Computes $(p_1,\dots,p_t)=f(\sigma(\vec C))$
        \State \textbf{(Server)} Store $h_j = H(\vec C , (p_1,\dots,p_t))$
        \State
        \State \Return $\vec C$
    \end{algorithmic}
\end{algorithm}


\begin{algorithm}
    \caption{Authentication process for account $A_j \in (A_1,\dots,A_m)$}\label{auth-proccess}
    \begin{algorithmic}[1]
        \Require
            \Statex \begin{itemize}
                \item Account $A_j \in (A_1,\dots, A_m)$
                \item Challenge $\vec C = (C_1,\dots,C_t)$ from account $A_j$.
                \item Hash $h_j$ and hash function $H$.
            \end{itemize}

            \For{$i=0 \rightarrow t$}
                \State Display $C_i$ to the user
                \State \textbf{User} Compute $p_i \leftarrow f(\sigma(C_i))$
                \State
                \Comment $p_i$ is the $i$'th character of the password for account $A$
            \EndFor

            \State $\vec P = (p_1,\dots,p_t)$
            \If{$h_j =H ( \vec C, \vec P )$}
            \Comment \textbf{(Server)} 
                \State Authenticated on account $A_j$
            \Else 
                \State Authentication failed
            \EndIf




    \end{algorithmic}
\end{algorithm}


\section{Usability}


