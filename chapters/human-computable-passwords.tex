\chapter{Human Computable Passwords}
The previous chapter concludes that managing passwords for online accounts has become a major issue for the modern Internet user. It seems to be impossible to remember and maintain enough strong passwords to keep all accounts secured. The scheme presented in this chapter is designed to help the user maintain and remember multiple strong passwords, while also protecting these after multiple passwords breaches. Human computable passwords takes advantage of the human brain allowing users to calculate passwords from public challenges, using their own mind to do so. 

\par The Human Computable Password management scheme is proposed by Blocki et al. in the paper \cite{hcp-blocki}. In addition to the scheme itself, the proposal introduce security and usability notions used to analyze the proposed scheme. This chapter will describe the scheme as well as associated security and usability concerns. The first section consist of definitions and notations as used in \cite{hcp-blocki} to describe the scheme. Next, Human computable Functions are introduced as this the main component used in the password management scheme which will be described after that. Finally the usability and security of the scheme is discussed and requirements defined.

\section{Password Management Scheme}
The main idea of the Human Computable Password management scheme is to have a set of challenges stored in persistent memory, typically on a computer or even a piece of paper. The user then use a mapping and a function to calculate the responses to each challenge, which eventually gives the password.

\subsection{Definitions and Notation}
The password management scheme uses a random mapping between a set of objects to single digits which has to be memorized by the user. This mapping is denoted as $\sigma : [n] \rightarrow \mathbb{Z}_d$. Random challenges will be generated and stored publicly in persistent memory. Let $C \in X_k$ be a random challenge chosen from $X_k$, the space of $k$ possible variables. Now $\sigma (C) \in \mathbb{Z}_d^k$ is the mapped variables corresponding to challenge $C$. The set of challenges $C$ can be any type of object, such as pictures letters or digits, with the mapping $\sigma$ always being to digits. One of these challenges, $C$, will be referred to as a \emph{single digit challenge}. The function $f: \mathbb{Z}^k_d \rightarrow \mathbb{Z}_d$ is a human computable function as discussed in the next section. The user will now be able to calculate the response to a challenge $C$ by computing $f(\sigma(C))$. A complete password challenge, $\vec(C) = (C_1,\dots,C_t) \in (X_k)^t$ , will consist of $t$ separate, single digit challenges. The response to $\vec(C)$, namely $f(\sigma(\vec(C)))$, is the complete password. 
\par The password management scheme works by generating one challenge, $\vec(C)$, for each of a user's accounts. The challenges $\vec(C_1),\dots,\vec(C_m) \in (X_k)^t$ are stored in persistent memory, available to "everybody". When a user wants to log in to a service he is shown the challenge corresponding to that account, the user then calculate the responses to all the single digit challenges, yielding the password.

\subsection{Human Computable Functions}
At the core of the scheme is a human computable function $f$ and the memorized mapping $\sigma$. The scheme require the composite function of these two $f \circ \sigma$ to be \emph{human computable}, which simply means that the function should be easily computable in the head of the user. To fulfill this requirement the function can't involve many operations, since the complexity and thus computation time would be too high. As shown by Miller \cite{magic-seven_miller}, a human can only store $7 \pm 2$ pieces of information at a given time, on the other hand humans are quite good at simple operations such as addition modulo 10. In example "1+6+5+3+8+9+3+1+4+6+7+7+6 mod 10" would be easy for most humans to compute by simply doing one operation at a time, updating the answer after each. With this approach only one piece of information would be stored in memory of the user at any time. The problem with such an expression is the amount of terms. 
\par The requirements needed for a function to be human computable can thus be summarized as the following, and formalized in Requirement \ref{human-function-req}:
\begin{itemize}
    \item Can only involve "simple" operations, mainly addition and recalling from long-term memory.
    \item Limited amount of terms.
    \item Limited amount of operations.
\end{itemize}
\begin{remark}
    All operations used in the human computable functions discussed in this project are modulo $10$, this is the most natural for most humans.
\end{remark}
\begin{requirement}
    \label{human-function-req}
    Function $f$ is said to be $\hat t$-human computable if a human can can compute it in his head in $\hat t$ seconds.
\end{requirement}

\par Blocki et al. \cite{hcp-blocki} believe that a function $f$ is human-computable if it can be computed using a fast streaming algorithm, meaning that the input is presented as a sequence of objects that only can be evaluated once. The algorithm would have to be simple since humans are not good at storing intermediate values \cite{magic-seven_miller}. Typical operations fast enough for the human to compute in his head is addition modulo 10 which is natural for most humans to do quickly, and recalling a mapped value $\sigma(i)$ from memory.

\begin{definition}
    \label{ptm-computable}
    A function $f$ is $(P, \tilde t, \hat m)$-computable if there is a space $\tilde m$ streaming algorithm computing $f$ using $\hat t$ operations from $P$.
\end{definition}
\begin{remark}
Space $\tilde m$ means that the algorithm requires no more than $\tilde m$ memory slots during calculation. Slots are typically used for storing values and executing primitive operations such as addition.
\end{remark}



\noindent As for the primitive operations in $P$, the following are considered:
\begin{itemize}
    \item{Add} takes two digits $x_1$ and $x_2$, and returns the sum $x_1 + x_2$ mod 10.
    \item{Recall} returns the secret value $\sigma(i)$ corresponding to a inputed index $i$. The mapping $\sigma$ is memorized by the user, allowing the recall operation to be done quickly in the users head.
    \item{TableLookup} involves looking up the x'th value from a table of 10 indices.
\end{itemize}

\begin{example}
    The function $f \circ \sigma(i_1,\dots,i_5) = \sigma(i_1) + \dots + \sigma(i_5)$ is $(P,9,3)$-computable, since it requires 9 operations from $P$, 5 recall operations and 4 add operations. $\tilde m=3$ since a sequence of additions $i_1 + \dots + i_n$, requires one slot for storing the sum, one slot for storing the next value in the sequence and one slot to execute the addition.
\end{example}


\subsection{Secure Human Computable Functions}
Blocki et al. \cite{hcp-blocki} suggest a family of human computable functions defined as follows.
\centerline{ $ f_{k_1,k_2}(x_0,\dots,x_{9+k_1+k_2})= x_j + \sum^{9+k_1+k_2}_{i=10+k_1} x_i$ mod 10, $j = \sum^{9+k_1}_{i=10} x_i$ mod 10. $k_1>0$, $k_2>0$ }

\par This project will use one of these functions, using $k_1=k_2=2$. From now on this will be the function referred to.

\begin{definition}
    $f(x_0,x_2,\dots,x_{13}) = x_{(x_{11} + x_{10}\space mod \space 10)} + x_{12} + x_{13}\space mod \space 10$ 
    \todo[inline]{fix formating}
\end{definition}



\section{Usability and Security Challenges}


